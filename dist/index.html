<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MathImage Settings</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'apple-gray': '#f5f5f7',
                        'apple-text': '#1d1d1f',
                        'apple-border': '#d2d2d7',
                        'apple-blue': '#007aff',
                    },
                    fontFamily: {
                        'apple': ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Status messages styling - only non-Tailwind custom styles */
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-weight: 500;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body class="font-apple bg-apple-gray min-h-screen p-5 text-apple-text">
    <div class="max-w-lg mx-auto bg-white rounded-xl shadow-lg overflow-visible min-h-[700px]">
        <div class="bg-white text-apple-text py-8 px-8 text-center border-b border-apple-border">
            <h1 class="text-3xl font-semibold tracking-tight">Settings</h1>
        </div>
        <div class="p-8">
            <form id="settingsForm" class="space-y-8">
                <!-- ÂÖ®Â±ÄËÆæÁΩÆÂå∫Âüü - ‰ºòÂÖàÊòæÁ§∫ -->
        <div class="mb-8">
            <h3 class="text-xl font-semibold text-apple-text mb-4 flex items-center gap-2">üåê Global Settings</h3>
            
            <div class="mb-6">
                <label class="block text-sm font-medium text-apple-text mb-2">Global Hotkey (Screenshot & Analyze):</label>
                <div class="flex gap-3 items-center">
                    <div class="flex-1 px-4 py-3 bg-gray-50 border border-apple-border rounded-lg font-mono font-semibold text-gray-700" id="globalHotkeyDisplay">Cmd+Shift+M</div>
                    <button type="button" class="px-4 py-3 bg-apple-blue text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" onclick="captureGlobalHotkey()">Change</button>
                </div>
            </div>
            
            <div class="mb-6">
                <label class="block text-sm font-medium text-apple-text mb-2">Switch Profile Hotkey:</label>
                <div class="flex gap-3 items-center">
                    <div class="flex-1 px-4 py-3 bg-gray-50 border border-apple-border rounded-lg font-mono font-semibold text-gray-700" id="switchHotkeyDisplay">Cmd+Shift+P</div>
                    <button type="button" class="px-4 py-3 bg-apple-blue text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" onclick="captureSwitchHotkey()">Change</button>
                </div>
                <div class="mt-2 text-xs text-gray-600">
                    Global hotkey: Take screenshot and analyze with current profile<br>
                    Switch hotkey: Cycle through profiles with notification<br>
                    <span class="text-gray-500">Note: Some combinations like Cmd+Shift+A/S may be reserved by the system.</span>
                </div>
            </div>
            
            <div class="mb-6">
                <label class="flex items-center gap-3 cursor-pointer">
                    <input type="checkbox" id="soundEnabled" class="w-4 h-4 text-apple-blue bg-gray-100 border-gray-300 rounded focus:ring-blue-500" onchange="autoSaveGlobalSettings()" />
                    <span class="text-sm font-medium text-apple-text">Enable sound notification after analysis</span>
                </label>
            </div>
        </div>
        
        <!-- ÂàÜÈöîÁ∫ø -->
        <hr class="my-8 border-gray-200" />
        
        <!-- ProfileÁÆ°ÁêÜÂíåÈÖçÁΩÆÂå∫Âüü -->
        <div class="mb-8">
            <h3 class="text-xl font-semibold text-apple-text mb-4 flex items-center gap-2">üë§ Profile Settings</h3>
        </div>

                <!-- Profile Management Section -->
                <div class="mb-5">
                    <label for="profileSelect" class="block text-sm font-medium text-apple-text mb-2">Active Profile:</label>
                    <!-- Tailwind CSS Dropdown -->
                    <div class="relative" id="profileDropdown">
                        <button type="button" 
                                class="relative w-full cursor-default rounded-md bg-white py-3 pl-4 pr-10 text-left text-apple-text border border-apple-border shadow-sm focus:border-apple-blue focus:outline-none focus:ring-1 focus:ring-apple-blue sm:text-sm"
                                id="profileButton" 
                                aria-haspopup="listbox" 
                                aria-expanded="false">
                            <span class="block truncate" id="profileButtonText">Select Profile...</span>
                            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
                                <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.76 9.2a.75.75 0 011.06.04l2.7 2.908 2.7-2.908a.75.75 0 111.08 1.04l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 01.04-1.06z" clip-rule="evenodd" />
                                </svg>
                            </span>
                        </button>
                        <ul class="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm hidden" 
                            id="profileOptions" 
                            tabindex="-1" 
                            role="listbox">
                            <!-- Profile options will be populated by JavaScript -->
                        </ul>
                    </div>
                    <select id="profileSelect" class="hidden">
                        <option value="">Select profile...</option>
                    </select>
                    <div class="flex gap-3 mt-3">
                        <button type="button" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors" onclick="createNewProfile()">New Profile</button>
                        <button type="button" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors" onclick="deleteCurrentProfile()">Delete Profile</button>
                    </div>
                </div>

                <!-- Current Profile Configuration -->
                <div class="mb-8">
                    <h3 class="text-lg font-semibold text-apple-text mb-4">Profile Configuration</h3>
                </div>

                <div class="mb-5">
                    <label for="profileName" class="block text-sm font-medium text-apple-text mb-2">Profile Name:</label>
                    <input type="text" id="profileName" placeholder="My Profile" 
                           class="w-full px-4 py-3 border border-apple-border rounded-lg text-apple-text bg-white focus:border-apple-blue focus:ring-1 focus:ring-apple-blue focus:outline-none transition-colors" />
                </div>

                <div class="mb-5">
                    <label for="apiBaseUrl" class="block text-sm font-medium text-apple-text mb-2">API Base URL:</label>
                    <input type="text" id="apiBaseUrl" placeholder="http://210.126.8.197:11434/v1" 
                           class="w-full px-4 py-3 border border-apple-border rounded-lg text-apple-text bg-white focus:border-apple-blue focus:ring-1 focus:ring-apple-blue focus:outline-none transition-colors" />
                </div>

                <div class="mb-5">
                    <label for="apiKey" class="block text-sm font-medium text-apple-text mb-2">API Key:</label>
                    <input type="password" id="apiKey" placeholder="sk-..." 
                           class="w-full px-4 py-3 border border-apple-border rounded-lg text-apple-text bg-white focus:border-apple-blue focus:ring-1 focus:ring-apple-blue focus:outline-none transition-colors" />
                </div>

                <div class="form-group">
                    <label for="model" class="block text-sm font-medium text-apple-text mb-2">Model:</label>
                    <!-- Tailwind CSS Dropdown for Model -->
                    <div class="relative" id="modelDropdown">
                        <button type="button" 
                                class="relative w-full cursor-default rounded-md bg-white py-3 pl-4 pr-10 text-left text-apple-text border border-apple-border shadow-sm focus:border-apple-blue focus:outline-none focus:ring-1 focus:ring-apple-blue sm:text-sm"
                                id="modelButton" 
                                aria-haspopup="listbox" 
                                aria-expanded="false">
                            <span class="block truncate" id="modelButtonText">Select a model...</span>
                            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
                                <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.76 9.2a.75.75 0 011.06.04l2.7 2.908 2.7-2.908a.75.75 0 111.08 1.04l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 01.04-1.06z" clip-rule="evenodd" />
                                </svg>
                            </span>
                        </button>
                        <ul class="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm hidden" 
                            id="modelOptions" 
                            tabindex="-1" 
                            role="listbox">
                            <!-- Model options will be populated by JavaScript -->
                        </ul>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select id="model" class="hidden">
                        <option value="">Select a model...</option>
                    </select>
                    <div class="flex gap-3 mt-3">
                        <button type="button" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors" onclick="loadModels()">Load Models</button>
                        <button type="button" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors" onclick="takeInteractiveScreenshot()">Screenshot & Analyze</button>
                        <button type="button" class="px-3 py-2 bg-cyan-600 text-white rounded-lg hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 transition-colors text-sm" onclick="testModelSelect()">Test Model Select</button>
                    </div>
                    <div class="mt-3 text-xs text-gray-500">
                        Click button or press <strong><span id="hotkeyDisplay" class="text-apple-blue">Cmd+Shift+M</span></strong> to select region with mouse
                    </div>
                </div>

                <div class="mb-5">
                    <label for="promptMode" class="block text-sm font-medium text-apple-text mb-2">Prompt Mode:</label>
                    <!-- Tailwind CSS Dropdown for Prompt Mode -->
                    <div class="relative" id="promptModeDropdown">
                        <button type="button" 
                                class="relative w-full cursor-default rounded-md bg-white py-3 pl-4 pr-10 text-left text-apple-text border border-apple-border shadow-sm focus:border-apple-blue focus:outline-none focus:ring-1 focus:ring-apple-blue sm:text-sm"
                                id="promptModeButton" 
                                aria-haspopup="listbox" 
                                aria-expanded="false">
                            <span class="block truncate" id="promptModeButtonText">Predefined Prompt</span>
                            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
                                <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.76 9.2a.75.75 0 011.06.04l2.7 2.908 2.7-2.908a.75.75 0 111.08 1.04l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 01.04-1.06z" clip-rule="evenodd" />
                                </svg>
                            </span>
                        </button>
                        <ul class="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm hidden" 
                            id="promptModeOptions" 
                            tabindex="-1" 
                            role="listbox">
                            <!-- Prompt mode options will be populated by JavaScript -->
                        </ul>
                    </div>
                    <select id="promptMode" class="hidden">
                        <option value="">Select prompt mode...</option>
                    </select>
                </div>

                <div class="mb-5" id="promptTextGroup">
                    <label for="prompt" class="block text-sm font-medium text-apple-text mb-2">Predefined Prompt:</label>
                    <textarea id="prompt" rows="3" placeholder="Describe what you see in this image..." 
                              class="w-full px-4 py-3 border border-apple-border rounded-lg text-apple-text bg-white focus:border-apple-blue focus:ring-1 focus:ring-apple-blue focus:outline-none resize-y transition-colors"></textarea>
                </div>

                <div class="mb-5">
                    <label for="outputMode" class="block text-sm font-medium text-apple-text mb-2">Output Mode:</label>
                    <!-- Tailwind CSS Dropdown for Output Mode -->
                    <div class="relative" id="outputModeDropdown">
                        <button type="button" 
                                class="relative w-full cursor-default rounded-md bg-white py-3 pl-4 pr-10 text-left text-apple-text border border-apple-border shadow-sm focus:border-apple-blue focus:outline-none focus:ring-1 focus:ring-apple-blue sm:text-sm"
                                id="outputModeButton" 
                                aria-haspopup="listbox" 
                                aria-expanded="false">
                            <span class="block truncate" id="outputModeButtonText">Clipboard</span>
                            <span class="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
                                <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.76 9.2a.75.75 0 011.06.04l2.7 2.908 2.7-2.908a.75.75 0 111.08 1.04l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 01.04-1.06z" clip-rule="evenodd" />
                                </svg>
                            </span>
                        </button>
                        <ul class="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm hidden" 
                            id="outputModeOptions" 
                            tabindex="-1" 
                            role="listbox">
                            <!-- Output mode options will be populated by JavaScript -->
                        </ul>
                    </div>
                    <select id="outputMode" class="hidden">
                        <option value="">Select output mode...</option>
                    </select>
                </div>

                <div class="flex gap-3 mb-8">
                    <button type="submit" class="flex-1 px-6 py-3 bg-apple-blue text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-apple-blue transition-colors font-medium">Save Profile Settings</button>
                    <button type="button" class="px-6 py-3 bg-gray-100 text-apple-text rounded-lg hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-300 transition-colors font-medium" onclick="loadSettings()">Reload Settings</button>
                </div>
            </form>

            <div id="status" class="status" style="display: none;"></div>
        </div>
    </div>

    <script>
        console.log('üöÄ Script loading started...');

        // JavaScriptÂàùÂßãÂåñÂÆåÊàê
        console.log('üîß JavaScript initialization started');

        // Import Tauri API dynamically
        let tauriReady = false;

        (async () => {
            try {
                const { invoke } = await import('https://unpkg.com/@tauri-apps/api@2/core');
                window.tauriInvoke = invoke;
                tauriReady = true;
                console.log('‚úÖ Tauri API loaded successfully');

                // Ëß¶ÂèëËÆæÁΩÆÂä†ËΩΩ
                if (typeof window.loadSettings === 'function') {
                    setTimeout(() => window.loadSettings(), 100);
                }
            } catch (error) {
                console.error('‚ùå Failed to load Tauri API:', error);
                // Fallback for testing
                window.tauriInvoke = function(cmd, args) {
                    console.log('Mock Tauri invoke:', cmd, args);
                    return Promise.resolve({
                        profiles: [],
                        active_profile_id: null,
                        global_hotkey: "cmd+shift+m",
                        switch_profile_hotkey: "cmd+shift+p",
                        sound_enabled: true
                    });
                };
                tauriReady = true;
            }
        })();

        // Á≠âÂæÖTauri APIÁöÑËæÖÂä©ÂáΩÊï∞
        window.waitForTauri = function() {
            return new Promise((resolve) => {
                if (tauriReady) {
                    resolve();
                } else {
                    const check = () => {
                        if (tauriReady) {
                            resolve();
                        } else {
                            setTimeout(check, 50);
                        }
                    };
                    check();
                }
            });
        };
        
        let isCapturingHotkey = false;
        let currentGlobalHotkey = "cmd+shift+m";
        let currentSwitchHotkey = "cmd+shift+p";
        let currentHotkeyType = null; // 'global' or 'switch'
        let currentProfiles = [];
        let currentActiveProfileId = null;
        let currentCaptureBtnEl = null; // track active capture button
        
        // Hotkey capture related variables
        let pressedKeys = new Set();
        let lastKeyEvent = null;
        let captureTimeout = null;
        let modifierKeysPressedCount = 0;

        console.log('üîß Variables initialized');

        function captureGlobalHotkey() {
            console.log('üîß captureGlobalHotkey called');
            currentHotkeyType = 'global';
            const captureBtn = event.target;
            const display = document.getElementById('globalHotkeyDisplay');
            startHotkeyCapture(captureBtn, display);
        }

        function captureSwitchHotkey() {
            console.log('üîß captureSwitchHotkey called');
            currentHotkeyType = 'switch';
            const captureBtn = event.target;
            const display = document.getElementById('switchHotkeyDisplay');
            startHotkeyCapture(captureBtn, display);
        }

        // Á´ãÂç≥Â∞ÜÂáΩÊï∞Êö¥Èú≤Âà∞ÂÖ®Â±Ä‰ΩúÁî®ÂüüÔºåÁ°Æ‰øùonclickÂèØ‰ª•ËÆøÈóÆ
        window.captureGlobalHotkey = captureGlobalHotkey;
        window.captureSwitchHotkey = captureSwitchHotkey;

        console.log('üîß Hotkey functions exposed to global scope');
        console.log('üîß Testing hotkey functions:', typeof window.captureGlobalHotkey, typeof window.captureSwitchHotkey);

        function startHotkeyCapture(captureBtn, display) {
            
            if (isCapturingHotkey) return;
            
            isCapturingHotkey = true;
            currentCaptureBtnEl = captureBtn;
            captureBtn.textContent = 'Press keys...';
            captureBtn.style.background = '#ff3b30';
            display.textContent = 'Press your desired key combination...';
            display.style.background = '#fff3cd';
            display.style.border = '1px solid #ffeaa7';
            
            // Ê∏ÖÁêÜ‰πãÂâçÁöÑÁä∂ÊÄÅ
            pressedKeys.clear();
            lastKeyEvent = null;
            modifierKeysPressedCount = 0;
            
            // ‰ΩøÁî®Êõ¥È´ò‰ºòÂÖàÁ∫ßÁöÑ‰∫ã‰ª∂ÊçïËé∑
            document.addEventListener('keydown', handleHotkeyCapture, true);
            document.addEventListener('keyup', handleHotkeyRelease, true);
            
            // Ê£ÄÊµãÁ≥ªÁªüÂø´Êç∑ÈîÆÂÜ≤Á™ÅÁöÑË∂ÖÊó∂Êú∫Âà∂
            setTimeout(() => {
                if (isCapturingHotkey && modifierKeysPressedCount > 0 && pressedKeys.size === modifierKeysPressedCount) {
                    display.textContent = 'System shortcut detected. Try a different combination or press ESC to cancel.';
                    display.style.background = '#ffe6e6';
                    display.style.border = '1px solid #ffaaaa';
                }
            }, 1500);
        }

        function handleHotkeyCapture(event) {
            // Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØ
            console.log('KeyDown - Key pressed:', event.key, 'code:', event.code, 'metaKey:', event.metaKey, 'shiftKey:', event.shiftKey, 'ctrlKey:', event.ctrlKey, 'altKey:', event.altKey);
            
            // Âº∫Âà∂ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫ÂíåÂÜíÊ≥°
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            
            // Check for ESC key to cancel
            if (event.key === 'Escape') {
                finishHotkeyCapture();
                return;
            }
            
            // ËÆ∞ÂΩïÊåâ‰∏ãÁöÑÈîÆ
            const wasNewKey = !pressedKeys.has(event.key);
            pressedKeys.add(event.key);
            lastKeyEvent = event;
            
            // ËÆ°ÁÆó‰øÆÈ•∞ÈîÆÊï∞Èáè
            if (wasNewKey && ['Meta', 'Control', 'Alt', 'Shift'].includes(event.key)) {
                modifierKeysPressedCount++;
            }
            
            // Ê∏ÖÈô§‰πãÂâçÁöÑË∂ÖÊó∂
            if (captureTimeout) {
                clearTimeout(captureTimeout);
            }
            
            // Â¶ÇÊûúÊ£ÄÊµãÂà∞Èùû‰øÆÈ•∞ÈîÆÔºåËÆæÁΩÆÁü≠ÊöÇÂª∂ËøüÂêéÂÆåÊàêÂΩïÂà∂
            if (!['Meta', 'Control', 'Alt', 'Shift'].includes(event.key)) {
                console.log('Non-modifier key detected:', event.key);
                captureTimeout = setTimeout(() => {
                    completeHotkeyCapture(event);
                }, 100); // 100ms Âª∂ËøüÁ°Æ‰øùÊâÄÊúâ‰øÆÈ•∞ÈîÆÁä∂ÊÄÅÁ®≥ÂÆö
                return;
            }
            
            // ÂÆûÊó∂Êõ¥Êñ∞ÊòæÁ§∫
            updateHotkeyDisplay();
        }

        function handleHotkeyRelease(event) {
            console.log('KeyUp - Key released:', event.key, 'code:', event.code);
            
            // Âº∫Âà∂ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            
            // Â¶ÇÊûúÊòØ‰øÆÈ•∞ÈîÆË¢´ÈáäÊîæÔºå‰∏çÂÅöÂ§ÑÁêÜ
            if (['Meta', 'Control', 'Alt', 'Shift'].includes(event.key)) {
                console.log('KeyUp - Modifier released:', event.key);
                return;
            }
            
            console.log('KeyUp - Non-modifier released:', event.key);
            
            // Ê∏ÖÈô§Ë∂ÖÊó∂ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            if (captureTimeout) {
                clearTimeout(captureTimeout);
                captureTimeout = null;
            }
            
            // Èùû‰øÆÈ•∞ÈîÆË¢´ÈáäÊîæÔºåÂÆåÊàêÂΩïÂà∂
            if (lastKeyEvent) {
                completeHotkeyCapture(lastKeyEvent);
            }
        }

        function updateHotkeyDisplay() {
            if (!lastKeyEvent) return;
            
            const keys = [];
            if (lastKeyEvent.metaKey) keys.push('cmd');
            if (lastKeyEvent.ctrlKey) keys.push('ctrl');
            if (lastKeyEvent.altKey) keys.push('alt');
            if (lastKeyEvent.shiftKey) keys.push('shift');
            
            // Ê∑ªÂä†Èùû‰øÆÈ•∞ÈîÆ
            const nonModifiers = Array.from(pressedKeys).filter(key => 
                !['Meta', 'Control', 'Alt', 'Shift', 'Escape'].includes(key)
            );
            
            if (nonModifiers.length > 0) {
                keys.push(nonModifiers[nonModifiers.length - 1].toLowerCase()); // ‰ΩøÁî®ÊúÄÂêéÊåâ‰∏ãÁöÑÈùû‰øÆÈ•∞ÈîÆ
            }
            
            // Ê†πÊçÆÂΩìÂâçÁÉ≠ÈîÆÁ±ªÂûãÊõ¥Êñ∞ÂØπÂ∫îÁöÑÊòæÁ§∫ÂÖÉÁ¥†
            let display;
            if (currentHotkeyType === 'global') {
                display = document.getElementById('globalHotkeyDisplay');
            } else if (currentHotkeyType === 'switch') {
                display = document.getElementById('switchHotkeyDisplay');
            }

            if (display && keys.length > 0) {
                display.textContent = formatHotkey(keys.join('+'));
            }
        }

        async function completeHotkeyCapture(event) {
            const keys = [];
            if (event.metaKey) keys.push('cmd');
            if (event.ctrlKey) keys.push('ctrl');
            if (event.altKey) keys.push('alt');
            if (event.shiftKey) keys.push('shift');
            
            // Ê∑ªÂä†Èùû‰øÆÈ•∞ÈîÆ
            const nonModifiers = Array.from(pressedKeys).filter(key => 
                !['Meta', 'Control', 'Alt', 'Shift', 'Escape'].includes(key)
            );
            
            if (nonModifiers.length > 0) {
                let keyName = nonModifiers[nonModifiers.length - 1].toLowerCase();
                
                // ÁâπÊÆäÊåâÈîÆÊò†Â∞Ñ
                const keyMap = {
                    ' ': 'space',
                    'enter': 'return',
                    'arrowup': 'up',
                    'arrowdown': 'down',
                    'arrowleft': 'left',
                    'arrowright': 'right'
                };
                
                if (keyMap[keyName]) {
                    keyName = keyMap[keyName];
                }
                
                keys.push(keyName);
            }
            
            if (keys.length > 0) {
                const hotkeyString = keys.join('+');
                console.log('Generated hotkey string:', hotkeyString);

                // Update the appropriate hotkey variable and display
                if (currentHotkeyType === 'global') {
                    currentGlobalHotkey = hotkeyString;
                    document.getElementById('globalHotkeyDisplay').textContent = formatHotkey(hotkeyString);
                    document.getElementById('hotkeyDisplay').textContent = formatHotkey(hotkeyString);
                } else if (currentHotkeyType === 'switch') {
                    currentSwitchHotkey = hotkeyString;
                    document.getElementById('switchHotkeyDisplay').textContent = formatHotkey(hotkeyString);
                }

                // Reset capture state
                finishHotkeyCapture();

                // Ëá™Âä®‰øùÂ≠òÁÉ≠ÈîÆËÆæÁΩÆ
                await autoSaveHotkeys();
            }
        }

        function formatHotkey(hotkeyString) {
            return hotkeyString
                .replace('cmd', 'Cmd')
                .replace('ctrl', 'Ctrl')
                .replace('alt', 'Alt')
                .replace('shift', 'Shift')
                .split('+')
                .join('+');
        }

        function finishHotkeyCapture() {
            isCapturingHotkey = false;

            // ÊâæÂà∞ÂΩìÂâçÊ≠£Âú®ÊçïËé∑ÁöÑÊåâÈíÆÂíåÊòæÁ§∫ÂÖÉÁ¥†
            let captureBtn, display;
            if (currentHotkeyType === 'global') {
                captureBtn = currentCaptureBtnEl || document.querySelector('#globalHotkeyDisplay').parentElement.querySelector('button');
                display = document.getElementById('globalHotkeyDisplay');
            } else if (currentHotkeyType === 'switch') {
                captureBtn = currentCaptureBtnEl || document.querySelector('#switchHotkeyDisplay').parentElement.querySelector('button');
                display = document.getElementById('switchHotkeyDisplay');
            }

            if (captureBtn) {
                captureBtn.textContent = 'Change';
                captureBtn.style.background = '#007aff';
            }

            if (display) {
                display.style.background = '#f8f9fa';
                display.style.border = '1px solid #d2d2d7';
            }
            currentCaptureBtnEl = null;
            
            // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®ÂíåÁä∂ÊÄÅ
            document.removeEventListener('keydown', handleHotkeyCapture, true);
            document.removeEventListener('keyup', handleHotkeyRelease, true);
            pressedKeys.clear();
            lastKeyEvent = null;
            
            // Ê∏ÖÁêÜË∂ÖÊó∂
            if (captureTimeout) {
                clearTimeout(captureTimeout);
                captureTimeout = null;
            }
        }

        // Ëá™Âä®‰øùÂ≠òÁÉ≠ÈîÆËÆæÁΩÆ
        async function autoSaveHotkeys() {
            try {
                if (window.tauriInvoke) {
                    console.log('üîÑ [DEBUG] Auto-saving hotkeys...');
                    await window.tauriInvoke('update_hotkeys', {
                        globalHotkey: currentGlobalHotkey,
                        switchHotkey: currentSwitchHotkey
                    });
                    
                    const hotkeyType = currentHotkeyType === 'global' ? 'Global' : 'Switch Profile';
                    const currentHotkey = currentHotkeyType === 'global' ? currentGlobalHotkey : currentSwitchHotkey;
                    showStatus(`${hotkeyType} hotkey saved: ${formatHotkey(currentHotkey)} - Applied immediately!`, 'success');
                    console.log('‚úÖ [DEBUG] Hotkeys auto-saved successfully - applied immediately');

                    // Update tray menu
                    try {
                        await window.tauriInvoke('refresh_tray_menu');
                    } catch (trayError) {
                        console.log('Failed to refresh tray menu after hotkey update:', trayError);
                    }
                }
            } catch (error) {
                console.error('‚ùå [DEBUG] Failed to auto-save hotkeys:', error);
                showStatus('Failed to save hotkeys: ' + error, 'error');
            }
        }

        // Ëá™Âä®‰øùÂ≠òÂÖ®Â±ÄËÆæÁΩÆ
        async function autoSaveGlobalSettings() {
            try {
                if (window.tauriInvoke) {
                    console.log('üîÑ [DEBUG] Auto-saving global settings...');
                    
                    // Ëé∑ÂèñÂΩìÂâçÂÖ®Â±ÄËÆæÁΩÆ
                    const soundEnabled = document.getElementById('soundEnabled').checked;
                    
                    // Ë∞ÉÁî®ÂêéÁ´ØÊõ¥Êñ∞ÂÖ®Â±ÄËÆæÁΩÆ
                    await window.tauriInvoke('update_hotkeys', {
                        globalHotkey: currentGlobalHotkey,
                        switchHotkey: currentSwitchHotkey
                    });
                    
                    // ËøôÈáåÂ∫îËØ•Êúâ‰∏Ä‰∏™ÂçïÁã¨ÁöÑAPIÊù•Êõ¥Êñ∞ÂÖ®Â±ÄËÆæÁΩÆÔºå‰ΩÜÊöÇÊó∂Áî®Áé∞ÊúâÁöÑ
                    console.log('‚úÖ [DEBUG] Global settings auto-saved');
                    showStatus('Settings saved automatically', 'success');
                }
            } catch (error) {
                console.error('‚ùå [DEBUG] Failed to auto-save global settings:', error);
                showStatus('Failed to save settings: ' + error, 'error');
            }
        }

        async function updateBackendHotkeys() {
            try {
                if (window.tauriInvoke) {
                    // Update both hotkeys in the backend
                    await window.tauriInvoke('update_hotkeys', {
                        globalHotkey: currentGlobalHotkey,
                        switchHotkey: currentSwitchHotkey
                    });
                    addDebug(`Backend hotkeys updated - Global: ${currentGlobalHotkey}, Switch: ${currentSwitchHotkey}`);

                    const hotkeyType = currentHotkeyType === 'global' ? 'Global' : 'Switch';
                    const currentHotkey = currentHotkeyType === 'global' ? currentGlobalHotkey : currentSwitchHotkey;
                    showStatus(`${hotkeyType} hotkey updated: ${formatHotkey(currentHotkey)}`, 'success');

                    // Update tray menu to show new hotkeys
                    try {
                        await window.tauriInvoke('update_tray_model', {
                            modelName: document.getElementById('model').value || "Not Selected"
                        });
                        addDebug('Tray menu updated with new hotkeys');
                    } catch (trayError) {
                        addDebug('Failed to update tray menu: ' + trayError);
                    }

                    // Settings will be saved manually
                }
            } catch (error) {
                addDebug('Failed to update backend hotkeys: ' + error);
                showStatus('Failed to update hotkeys: ' + error, 'error');
            }
        }

        // Ëá™ÂÆö‰πâËæìÂÖ•ÂØπËØùÊ°ÜÂáΩÊï∞
        function showInputDialog(title, message, defaultValue = '') {
            return new Promise((resolve) => {
                // ÂàõÂª∫Ê®°ÊÄÅÂØπËØùÊ°Ü
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: rgba(0,0,0,0.5); display: flex; align-items: center;
                    justify-content: center; z-index: 10000;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white; padding: 30px; border-radius: 15px;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 400px; width: 90%;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                `;

                const titleEl = document.createElement('h3');
                titleEl.textContent = title;
                titleEl.style.cssText = `
                    margin: 0 0 15px 0; color: #1d1d1f; font-size: 20px; font-weight: 600;
                `;

                const messageEl = document.createElement('p');
                messageEl.textContent = message;
                messageEl.style.cssText = `
                    margin: 0 0 20px 0; color: #1d1d1f; font-size: 16px;
                `;

                const input = document.createElement('input');
                input.type = 'text';
                input.value = defaultValue;
                input.style.cssText = `
                    width: 100%; padding: 12px 16px; border: 1px solid #d2d2d7;
                    border-radius: 8px; font-size: 16px; margin-bottom: 20px;
                    box-sizing: border-box;
                `;

                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    display: flex; gap: 10px; justify-content: flex-end;
                `;

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.cssText = `
                    padding: 10px 20px; border: 1px solid #d2d2d7; background: white;
                    border-radius: 8px; font-size: 16px; cursor: pointer;
                `;

                const okBtn = document.createElement('button');
                okBtn.textContent = 'OK';
                okBtn.style.cssText = `
                    padding: 10px 20px; border: none; background: #007aff; color: white;
                    border-radius: 8px; font-size: 16px; cursor: pointer;
                `;

                // ‰∫ã‰ª∂Â§ÑÁêÜ
                const handleOk = () => {
                    const value = input.value.trim();
                    document.body.removeChild(modal);
                    resolve(value || null);
                };

                const handleCancel = () => {
                    document.body.removeChild(modal);
                    resolve(null);
                };

                okBtn.addEventListener('click', handleOk);
                cancelBtn.addEventListener('click', handleCancel);

                // EnterÈîÆÁ°ÆËÆ§
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleOk();
                    }
                });

                // EscapeÈîÆÂèñÊ∂à
                modal.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        handleCancel();
                    }
                });

                // ÁªÑË£ÖÂØπËØùÊ°Ü
                buttonContainer.appendChild(cancelBtn);
                buttonContainer.appendChild(okBtn);
                
                dialog.appendChild(titleEl);
                dialog.appendChild(messageEl);
                dialog.appendChild(input);
                dialog.appendChild(buttonContainer);
                
                modal.appendChild(dialog);
                document.body.appendChild(modal);

                // Ëá™Âä®ËÅöÁÑ¶Âà∞ËæìÂÖ•Ê°Ü
                setTimeout(() => input.focus(), 100);
            });
        }

        // Profile Management Functions
        async function createNewProfile() {
            console.log('üîß [DEBUG] createNewProfile() called');

            // Á≠âÂæÖTauri APIÂáÜÂ§áÂ∞±Áª™
            await window.waitForTauri();

            // ÂàõÂª∫Ëá™ÂÆö‰πâËæìÂÖ•ÂØπËØùÊ°Ü
            const profileName = await showInputDialog('Create New Profile', 'Enter profile name:', 'New Profile');

            if (!profileName || profileName.trim() === '') {
                console.log('‚ùå [DEBUG] Profile creation cancelled - no name provided');
                return;
            }

            console.log('‚úÖ [DEBUG] Profile name to use:', profileName.trim());

            try {
                const newProfile = {
                    name: profileName.trim(),
                    api_config: {
                        base_url: 'http://210.126.8.197:11434/v1',
                        api_key: '',
                        model: ''
                    },
                    prompt_mode: 'predefined',
                    predefined_prompt: 'ËØÜÂà´ÂÖ¨ÂºèÂíåÊñáÂ≠óÔºåËøîÂõû‰ΩøÁî®pandocËØ≠Ê≥ïÁöÑmarkdownÊéíÁâàÂÜÖÂÆπ„ÄÇÂÖ¨ÂºèËØ∑Áî®katexËØ≠Ê≥ïÂåÖË£πÔºåÊñáÂ≠óÂÜÖÂÆπ‰∏çË¶Å‰∏¢Â§±„ÄÇÂè™ËøîÂõûÂÜÖÂÆπ‰∏çÈúÄË¶ÅÂÖ∂‰ªñËß£Èáä„ÄÇ',
                    output_mode: 'clipboard'
                };

                console.log('üì¶ [DEBUG] Creating profile with data:', newProfile);
                console.log('üöÄ [DEBUG] Calling create_profile...');

                await window.tauriInvoke('create_profile', { profile: newProfile });

                console.log('‚úÖ [DEBUG] Profile creation call completed');
                addDebug('Profile created: ' + profileName);
                showStatus('Profile created: ' + profileName, 'success');

                // Reload profiles and settings
                await loadSettings();

                // Âà∑Êñ∞ÊâòÁõòËèúÂçï
                try {
                    await window.tauriInvoke('refresh_tray_menu');
                    addDebug('Tray menu refreshed after profile creation');
                } catch (trayError) {
                    addDebug('Failed to refresh tray menu: ' + trayError);
                }
            } catch (error) {
                addDebug('Failed to create profile: ' + error);
                showStatus('Failed to create profile: ' + error, 'error');
            }
        }

        console.log('üîß createNewProfile function defined');

        // Á´ãÂç≥Êö¥Èú≤createNewProfileÂà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü
        window.createNewProfile = createNewProfile;

        console.log('üîß createNewProfile exposed to global scope');
        console.log('üîß Testing createNewProfile:', typeof window.createNewProfile);

        // ÁßªÈô§editCurrentProfileÂáΩÊï∞ - Áé∞Âú®ÁºñËæëÊòØËá™Âä®ÁöÑ
        // ÂΩìÂàáÊç¢profileÊó∂ÔºåÁïåÈù¢‰ºöËá™Âä®Âä†ËΩΩËØ•profileÁöÑÈÖçÁΩÆËøõË°åÁºñËæë
        /*
        async function editCurrentProfile() {
            if (!currentActiveProfileId) {
                showStatus('No active profile to edit', 'error');
                return;
            }

            const newName = prompt('Enter new profile name:', getCurrentProfileName());
            if (!newName || newName.trim() === '') return;

            try {
                await window.tauriInvoke('update_profile_name', {
                    profileId: currentActiveProfileId,
                    newName: newName.trim()
                });
                addDebug('Profile renamed to: ' + newName);
                showStatus('Profile renamed to: ' + newName, 'success');

                // Reload profiles and settings
                await loadSettings();
            } catch (error) {
                addDebug('Failed to rename profile: ' + error);
                showStatus('Failed to rename profile: ' + error, 'error');
            }
        }
        */

        async function deleteCurrentProfile() {
            if (!currentActiveProfileId) {
                showStatus('No active profile to delete', 'error');
                return;
            }

            if (currentProfiles.length <= 1) {
                showStatus('Cannot delete the last profile', 'error');
                return;
            }

            const profileName = getCurrentProfileName();
            if (!confirm(`Are you sure you want to delete profile "${profileName}"?`)) return;

            try {
                await window.tauriInvoke('delete_profile', { profileId: currentActiveProfileId });
                addDebug('Profile deleted: ' + profileName);
                showStatus('Profile deleted: ' + profileName, 'success');

                // Reload profiles and settings
                await loadSettings();
            } catch (error) {
                addDebug('Failed to delete profile: ' + error);
                showStatus('Failed to delete profile: ' + error, 'error');
            }
        }

        // Á´ãÂç≥Êö¥Èú≤deleteCurrentProfileÂà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü
        window.deleteCurrentProfile = deleteCurrentProfile;

        console.log('üîß deleteCurrentProfile exposed to global scope');

        function getCurrentProfileName() {
            const activeProfile = currentProfiles.find(p => p.id === currentActiveProfileId);
            return activeProfile ? activeProfile.name : 'Unknown Profile';
        }

        async function switchToProfile(profileId) {
            try {
                await window.tauriInvoke('set_active_profile', { profileId });
                currentActiveProfileId = profileId;
                addDebug('Switched to profile: ' + profileId);

                // Reload settings to reflect the new active profile
                await loadSettings();
            } catch (error) {
                addDebug('Failed to switch profile: ' + error);
                showStatus('Failed to switch profile: ' + error, 'error');
            }
        }

        function addDebug(message) {
            // Simple console logging instead of DOM manipulation
            console.log('[Debug]', new Date().toLocaleTimeString(), message);
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 3000);
        }

        async function takeInteractiveScreenshot() {
            addDebug('Take interactive screenshot clicked');
            try {
                if (!window.tauriInvoke) {
                    addDebug('ERROR: Tauri invoke not available');
                    showStatus('Tauri API not available', 'error');
                    return;
                }

                addDebug('Starting interactive screenshot - select region with mouse...');
                showStatus('Select region with mouse cursor...', 'success');

                const imageData = await window.tauriInvoke('take_interactive_screenshot');
                addDebug('Interactive screenshot taken, analyzing...');

                const result = await window.tauriInvoke('analyze_image', { imageData });
                addDebug('Analysis result: ' + result);

                // Copy to clipboard
                try {
                    await window.tauriInvoke('copy_to_clipboard', { text: result });
                    addDebug('Result copied to clipboard');
                    showStatus('Screenshot analyzed and copied to clipboard!', 'success');
                } catch (clipboardError) {
                    addDebug('Failed to copy to clipboard: ' + clipboardError);
                    showStatus('Screenshot analyzed successfully!', 'success');
                }

                // Result is already copied to clipboard, no need for modal
            } catch (error) {
                addDebug('Interactive screenshot error: ' + error);
                if (error.toString().includes('cancelled')) {
                    showStatus('Screenshot cancelled', 'error');
                } else {
                    showStatus('Screenshot failed: ' + error, 'error');

                    // Show system notification
                    try {
                        await window.tauriInvoke('show_system_notification', {
                            title: 'MathImage Error',
                            message: 'Screenshot failed: ' + error
                        });
                    } catch (notifError) {
                        addDebug('Failed to show notification: ' + notifError);
                    }
                }
            }
        }

        // Á´ãÂç≥Êö¥Èú≤takeInteractiveScreenshotÂà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü
        window.takeInteractiveScreenshot = takeInteractiveScreenshot;

        async function takeRegionScreenshot() {
            addDebug('Take region screenshot clicked');

            // Show region selection dialog
            const regionDialog = `
                <div style="margin: 10px 0;">
                    <label>X coordinate: <input type="number" id="regionX" value="540" style="width: 80px;"></label>
                    <label>Y coordinate: <input type="number" id="regionY" value="300" style="width: 80px;"></label>
                </div>
                <div style="margin: 10px 0;">
                    <label>Width: <input type="number" id="regionW" value="800" style="width: 80px;"></label>
                    <label>Height: <input type="number" id="regionH" value="600" style="width: 80px;"></label>
                </div>
                <div style="margin: 10px 0; font-size: 12px; color: #666;">
                    Tip: Use smaller regions (400x300) for faster processing
                </div>
            `;

            // Create a simple modal dialog
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); display: flex; align-items: center;
                justify-content: center; z-index: 1000;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;

            dialog.innerHTML = `
                <h3>Select Screenshot Region</h3>
                ${regionDialog}
                <div style="margin-top: 15px;">
                    <button id="confirmRegion" class="btn-primary">Take Screenshot</button>
                    <button id="cancelRegion" class="btn-secondary" style="margin-left: 10px;">Cancel</button>
                </div>
            `;

            modal.appendChild(dialog);
            document.body.appendChild(modal);

            // Handle dialog buttons
            document.getElementById('confirmRegion').onclick = async () => {
                const regionX = parseInt(document.getElementById('regionX').value) || 540;
                const regionY = parseInt(document.getElementById('regionY').value) || 300;
                const regionW = parseInt(document.getElementById('regionW').value) || 800;
                const regionH = parseInt(document.getElementById('regionH').value) || 600;

                document.body.removeChild(modal);

                try {
                    if (!window.tauriInvoke) {
                        addDebug('ERROR: Tauri invoke not available');
                        showStatus('Tauri API not available', 'error');
                        return;
                    }

                    addDebug(`Taking region screenshot: ${regionX},${regionY} ${regionW}x${regionH}`);
                    const imageData = await window.tauriInvoke('take_screenshot_region', {
                        x: regionX,
                        y: regionY,
                        width: regionW,
                        height: regionH
                    });
                    addDebug('Region screenshot taken, analyzing...');

                    const result = await window.tauriInvoke('analyze_image', { imageData });
                    addDebug('Analysis result: ' + result);

                    // Copy to clipboard
                    try {
                        await window.tauriInvoke('copy_to_clipboard', { text: result });
                        addDebug('Result copied to clipboard');
                        showStatus('Screenshot analyzed and copied to clipboard!', 'success');
                    } catch (clipboardError) {
                        addDebug('Failed to copy to clipboard: ' + clipboardError);
                        showStatus('Screenshot analyzed successfully!', 'success');
                    }

                    // Show result in a popup or dedicated area
                    alert('Analysis Result (copied to clipboard):\n\n' + result);
                } catch (error) {
                    addDebug('Region screenshot error: ' + error);
                    showStatus('Region screenshot failed: ' + error, 'error');
                }
            };

            document.getElementById('cancelRegion').onclick = () => {
                document.body.removeChild(modal);
                addDebug('Region screenshot cancelled');
            };
        }

        async function loadModels() {
            addDebug('Load models clicked');
            
            // First check if we have pre-loaded models from tray
            try {
                const preLoadedModels = await window.tauriInvoke('get_loaded_models');
                if (preLoadedModels && preLoadedModels.length > 0) {
                    addDebug(`Found ${preLoadedModels.length} pre-loaded models from tray`);
                    
                    const select = document.getElementById('model');
                    select.innerHTML = '<option value="">Select a model...</option>';
                    preLoadedModels.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        select.appendChild(option);
                    });

                    // Update Tailwind model dropdown
                    updateModelDropdown(preLoadedModels);

                    showStatus(`Loaded ${preLoadedModels.length} models from cache`, 'success');
                    showSuccessToast(`Successfully loaded ${preLoadedModels.length} models`);

                    // Êõ¥Êñ∞Ëá™ÂÆö‰πâselect
                    if (window.updateCustomSelectOptions) {
                        window.updateCustomSelectOptions();
                    }
                    return;
                }
            } catch (preLoadError) {
                addDebug('No pre-loaded models available: ' + preLoadError);
            }
            
            // Fallback to API fetch if no pre-loaded models
            const baseUrl = document.getElementById('apiBaseUrl').value;
            const apiKey = document.getElementById('apiKey').value;

            if (!baseUrl || !apiKey) {
                showStatus('Please enter API URL and key first', 'error');
                return;
            }

            try {
                const models = await window.tauriInvoke('get_models', { baseUrl, apiKey });
                addDebug(`Loaded ${models.length} models from API`);

                const select = document.getElementById('model');
                select.innerHTML = '<option value="">Select a model...</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    select.appendChild(option);
                });

                // Update Tailwind model dropdown
                const modelIds = models.map(model => model.id);
                updateModelDropdown(modelIds);

                // Update tray menu with loaded models
                try {
                    await window.tauriInvoke('refresh_tray_models');
                    addDebug('Tray menu updated with loaded models');
                } catch (trayError) {
                    addDebug('Failed to update tray menu: ' + trayError);
                }

                showStatus(`Loaded ${models.length} models`, 'success');
                showSuccessToast(`Successfully loaded ${models.length} models`);

                // Êõ¥Êñ∞Ëá™ÂÆö‰πâselect
                // Update Tailwind dropdowns
                updateProfileSelector();
                updateModelDropdown();
            } catch (error) {
                addDebug('Load models error: ' + error);
                showStatus('Failed to load models: ' + error, 'error');
            }
        }

        // Á´ãÂç≥Êö¥Èú≤loadModelsÂà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü
        window.loadModels = loadModels;



        async function loadSettings() {
            try {
                // Á≠âÂæÖTauri APIÂáÜÂ§áÂ∞±Áª™
                await window.waitForTauri();

                const config = await window.tauriInvoke('get_config');

                // Store profiles and active profile info
                currentProfiles = config.profiles || [];
                currentActiveProfileId = config.active_profile_id;

                // Get active profile
                const activeProfile = currentProfiles.find(p => p.id === currentActiveProfileId) || currentProfiles[0];

                if (activeProfile) {
                    // Load profile-specific settings
                    document.getElementById('profileName').value = activeProfile.name || '';
                    document.getElementById('apiBaseUrl').value = activeProfile.api_config?.base_url || '';
                    document.getElementById('apiKey').value = activeProfile.api_config?.api_key || '';

                    // Handle prompt mode (Tailwind dropdown + hidden select)
                    const promptMode = activeProfile.prompt_mode;
                    const promptModeSelect = document.getElementById('promptMode');
                    const promptModeButtonText = document.getElementById('promptModeButtonText');
                    const promptTextGroup = document.getElementById('promptTextGroup');

                    if (typeof promptMode === 'object' && promptMode.Predefined) {
                        document.getElementById('prompt').value = promptMode.Predefined;
                        if (promptModeSelect) promptModeSelect.value = 'Predefined';
                        if (promptModeButtonText) promptModeButtonText.textContent = 'Predefined Prompt';
                        if (promptTextGroup) promptTextGroup.style.display = 'block';
                    } else if (promptMode === 'UserInput' || (typeof promptMode === 'object' && promptMode.UserInput !== undefined)) {
                        if (promptModeSelect) promptModeSelect.value = 'UserInput';
                        if (promptModeButtonText) promptModeButtonText.textContent = 'User Input (ÊØèÊ¨°ËØ¢ÈóÆ)';
                        if (promptTextGroup) promptTextGroup.style.display = 'none';
                    } else {
                        // Default to predefined with existing prompt text if any
                        if (promptModeSelect) promptModeSelect.value = 'Predefined';
                        if (promptModeButtonText) promptModeButtonText.textContent = 'Predefined Prompt';
                        document.getElementById('prompt').value = (typeof promptMode === 'string') ? promptMode : '';
                        if (promptTextGroup) promptTextGroup.style.display = 'block';
                    }

                    // Handle output mode (Tailwind dropdown + hidden select)
                    const outputMode = activeProfile.output_mode;
                    const outputModeSelect = document.getElementById('outputMode');
                    const outputModeButtonText = document.getElementById('outputModeButtonText');
                    if (outputMode === 'Dialog' || (typeof outputMode === 'object' && outputMode.Dialog !== undefined)) {
                        if (outputModeSelect) outputModeSelect.value = 'Dialog';
                        if (outputModeButtonText) outputModeButtonText.textContent = 'Dialog (ÊòæÁ§∫ÂØπËØùÊ°Ü)';
                    } else {
                        if (outputModeSelect) outputModeSelect.value = 'Clipboard';
                        if (outputModeButtonText) outputModeButtonText.textContent = 'Clipboard (Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø)';
                    }

                    // Update model selection
                    const modelSelect = document.getElementById('model');
                    const selectedModel = activeProfile.api_config?.model || '';
                    if (selectedModel && selectedModel.trim() !== '') {
                        const modelExists = Array.from(modelSelect.options).some(option => option.value === selectedModel);
                        if (!modelExists) {
                            addDebug('Model from profile not found in select, loading models first...');
                            try {
                                await loadModels();
                                modelSelect.value = selectedModel;
                                addDebug(`Model set to: ${selectedModel} after loading models`);
                            } catch (modelLoadError) {
                                addDebug('Failed to load models when setting profile model: ' + modelLoadError);
                                modelSelect.value = selectedModel;
                            }
                        } else {
                            modelSelect.value = selectedModel;
                            addDebug(`Model set to: ${selectedModel}`);
                        }

                        // Update Tailwind model dropdown
                        updateModelDropdown();
                        const modelButtonText = document.getElementById('modelButtonText');
                        if (modelButtonText && selectedModel) {
                            modelButtonText.textContent = selectedModel;
                        }
                    } else {
                        modelSelect.value = '';
                        // Clear Tailwind model dropdown
                        const modelButtonText = document.getElementById('modelButtonText');
                        if (modelButtonText) {
                            modelButtonText.textContent = 'Select a model...';
                        }
                    }
                }

                // Load global settings
                document.getElementById('soundEnabled').checked = config.sound_enabled !== false;

                // Load hotkeys
                if (config.global_hotkey) {
                    currentGlobalHotkey = config.global_hotkey;
                    const formatted = formatHotkey(config.global_hotkey);
                    document.getElementById('hotkeyDisplay').textContent = formatted;
                    document.getElementById('globalHotkeyDisplay').textContent = formatted;
                }

                if (config.switch_profile_hotkey) {
                    currentSwitchHotkey = config.switch_profile_hotkey;
                    const formatted = formatHotkey(config.switch_profile_hotkey);
                    document.getElementById('switchHotkeyDisplay').textContent = formatted;
                }

                // Update profile selector
                updateProfileSelector();
                
                // Handle model setting - check if we need to load models first
                const modelSelect = document.getElementById('model');
                if (config.model && config.model.trim() !== '') {
                    // Check if the model option already exists
                    const modelExists = Array.from(modelSelect.options).some(option => option.value === config.model);
                    
                    if (!modelExists) {
                        // Model doesn't exist in select, try to load models first
                        addDebug('Model from config not found in select, loading models first...');
                        try {
                            await loadModels();
                            // After loading models, try to set the model again
                            modelSelect.value = config.model;
                            addDebug(`Model set to: ${config.model} after loading models`);
                        } catch (modelLoadError) {
                            addDebug('Failed to load models when setting config model: ' + modelLoadError);
                            modelSelect.value = config.model; // Set anyway, might work
                        }
                    } else {
                        // Model option exists, set it directly
                        modelSelect.value = config.model;
                        addDebug(`Model set to: ${config.model}`);
                    }
                } else {
                    // No model in config, just clear the selection
                    modelSelect.value = '';
                }
                
                addDebug('Settings loaded');

                // Êõ¥Êñ∞Ëá™ÂÆö‰πâselect
                // Update Tailwind dropdowns
                updateProfileSelector();
                updateModelDropdown();
            } catch (error) {
                addDebug('Load settings error: ' + error);
            }
        }

        // Á´ãÂç≥Êö¥Èú≤loadSettingsÂà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü
        window.loadSettings = loadSettings;

        console.log('üîß loadSettings exposed to global scope');

        async function saveSettings() {
            try {
                // Ëé∑ÂèñÂΩìÂâçÈÄâÊã©ÁöÑpromptÊ®°ÂºèÂíåËæìÂá∫Ê®°ÂºèÔºàÂü∫‰∫éÈöêËóèÁöÑÂéüÁîüselectÔºâ
                const promptModeSelect = document.getElementById('promptMode');
                const outputModeSelect = document.getElementById('outputMode');

                const promptMode = (promptModeSelect && promptModeSelect.value === 'UserInput') ? 'user_input' : 'predefined';
                const outputMode = (outputModeSelect && outputModeSelect.value === 'Dialog') ? 'dialog' : 'clipboard';

                const profileData = {
                    profileName: document.getElementById('profileName').value,
                    apiBaseUrl: document.getElementById('apiBaseUrl').value,
                    apiKey: document.getElementById('apiKey').value,
                    model: document.getElementById('model').value,
                    prompt: document.getElementById('prompt').value,
                    promptMode: promptMode,
                    outputMode: outputMode,
                    soundEnabled: document.getElementById('soundEnabled').checked
                };

                await window.tauriInvoke('update_profile_config', { profileData });

                // Êõ¥Êñ∞ProfileÈÄâÊã©Âô®ÊòæÁ§∫
                const profileName = document.getElementById('profileName').value;
                if (profileName && profileName.trim() !== '') {
                    const profileButtonText = document.getElementById('profileButtonText');
                    if (profileButtonText) {
                        profileButtonText.textContent = profileName.trim();
                    }
                }

                showStatus('Settings saved!', 'success');
                addDebug('Settings saved manually');
            } catch (error) {
                showStatus('Failed to save: ' + error, 'error');
                addDebug('Save error: ' + error);
            }
        }

        // Á´ãÂç≥Êö¥Èú≤saveSettingsÂà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü
        window.saveSettings = saveSettings;

        // ÁÆÄÂåñÁöÑÈÖçÁΩÆ‰øùÂ≠òÈÄªËæë
        let autoSaveTimeout;

        async function autoSaveSettings() {
            // Á¶ÅÁî®Ëá™Âä®‰øùÂ≠òÔºåÊîπ‰∏∫ÊâãÂä®‰øùÂ≠ò
            addDebug('Auto-save disabled, use manual save instead');
        }

        function showErrorModal(errorMessage) {
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.6); display: flex; align-items: center;
                justify-content: center; z-index: 1000;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 30px; border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 400px;
                text-align: center; border-left: 5px solid #dc3545;
            `;

            dialog.innerHTML = `
                <div style="color: #dc3545; font-size: 48px; margin-bottom: 15px;">‚ö†Ô∏è</div>
                <h3 style="color: #dc3545; margin: 0 0 15px 0;">Error</h3>
                <div style="color: #666; margin-bottom: 20px; line-height: 1.5;">${errorMessage}</div>
                <button id="closeError" class="btn-primary" style="min-width: 100px;">OK</button>
            `;

            modal.appendChild(dialog);
            document.body.appendChild(modal);

            // Close button handler
            document.getElementById('closeError').onclick = () => {
                document.body.removeChild(modal);
            };

            // Click outside to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };

            // Auto close after 5 seconds
            setTimeout(() => {
                if (document.body.contains(modal)) {
                    document.body.removeChild(modal);
                }
            }, 5000);
        }

        function showSuccessToast(message) {
            // Create toast with Apple design
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed; top: 20px; right: 20px;
                background: rgba(255, 255, 255, 0.95); color: #1d1d1f;
                padding: 12px 16px; border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                backdrop-filter: blur(20px); border: 1px solid rgba(0, 0, 0, 0.1);
                z-index: 1000; font-weight: 500; font-size: 14px;
                transform: translateY(-20px) scale(0.95); opacity: 0;
                transition: all 0.3s ease;
            `;

            toast.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 6px; height: 6px; background: #34c759; border-radius: 50%;"></div>
                    <span>${message}</span>
                </div>
            `;

            document.body.appendChild(toast);

            // Animate in
            setTimeout(() => {
                toast.style.transform = 'translateY(0) scale(1)';
                toast.style.opacity = '1';
            }, 100);

            // Auto remove after 3 seconds
            setTimeout(() => {
                toast.style.transform = 'translateY(-20px) scale(0.95)';
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (document.body.contains(toast)) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        document.getElementById('settingsForm').addEventListener('submit', (e) => {
            e.preventDefault();
            saveSettings();
        });

        // Initialize
        window.addEventListener('load', () => {
            addDebug('Page loaded');

            // ÂÖàÂàùÂßãÂåñÊâÄÊúâËá™ÂÆö‰πâselectÔºàTailwind ÁâàÊú¨Âú®‰∏ãÊñπÂàùÂßãÂåñÔºâ
            initCustomSelect();
            initProfileSelect();
            // ÁßªÈô§‰∏çÂ≠òÂú®ÁöÑÂàùÂßãÂåñË∞ÉÁî®Ôºå‰ΩøÁî®TailwindÂàùÂßãÂåñ

            // Check for Tauri invoke with multiple attempts
            function checkTauriAPI(attempts = 0) {
                addDebug(`Checking Tauri invoke (attempt ${attempts + 1})`);
                addDebug(`window.tauriInvoke exists: ${!!window.tauriInvoke}`);

                if (window.tauriInvoke) {
                    addDebug('Tauri invoke detected');
                    loadSettings();
                    return;
                }

                if (attempts < 10) {
                    setTimeout(() => checkTauriAPI(attempts + 1), 200);
                } else {
                    addDebug('ERROR: Tauri invoke not found after 10 attempts');
                    addDebug('Module import might have failed');
                }
            }

            checkTauriAPI();
        });

        // Listen for global shortcut events
        if (window.__TAURI__ && window.__TAURI__.event) {
            window.__TAURI__.event.listen('analysis_result', (event) => {
                addDebug('Global shortcut analysis result: ' + event.payload);
                showStatus('Screenshot analyzed via hotkey and copied to clipboard!', 'success');
                // Don't show alert for hotkey results since they're copied to clipboard
            });

            window.__TAURI__.event.listen('analysis_error', (event) => {
                addDebug('Global shortcut analysis error: ' + event.payload);
                // System notification is shown by backend, no need for modal
            });

            window.__TAURI__.event.listen('screenshot_error', (event) => {
                addDebug('Global shortcut screenshot error: ' + event.payload);
                // Error dialog is shown by backend, no need for modal
            });

            window.__TAURI__.event.listen('show_error_dialog', (event) => {
                addDebug('Showing error dialog: ' + event.payload);
                showErrorModal(event.payload);
            });
        }

        // Profile and UI Helper Functions
        function updateProfileSelector() {
            const profileSelect = document.getElementById('profileSelect');

            if (!profileSelect) return;

            // Clear existing options except the first one
            profileSelect.innerHTML = '<option value="">Select Profile...</option>';

            // Add profile options
            currentProfiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.id;
                option.textContent = profile.name;
                
                if (profile.id === currentActiveProfileId) {
                    option.selected = true;
                }

                profileSelect.appendChild(option);
            });
        }

        function updatePromptModeSelect(mode) {
            // Bridge legacy calls to Tailwind dropdown + hidden select
            const hiddenSelect = document.getElementById('promptMode');
            const btnText = document.getElementById('promptModeButtonText');
            const promptTextGroup = document.getElementById('promptTextGroup');

            if (mode === 'predefined') {
                if (hiddenSelect) hiddenSelect.value = 'Predefined';
                if (btnText) btnText.textContent = 'Predefined Prompt';
                if (promptTextGroup) promptTextGroup.style.display = 'block';
            } else if (mode === 'user_input') {
                if (hiddenSelect) hiddenSelect.value = 'UserInput';
                if (btnText) btnText.textContent = 'User Input (ÊØèÊ¨°ËØ¢ÈóÆ)';
                if (promptTextGroup) promptTextGroup.style.display = 'none';
            }
        }

        function updateOutputModeSelect(mode) {
            // Bridge legacy calls to Tailwind dropdown + hidden select
            const hiddenSelect = document.getElementById('outputMode');
            const btnText = document.getElementById('outputModeButtonText');

            if (mode === 'clipboard') {
                if (hiddenSelect) hiddenSelect.value = 'Clipboard';
                if (btnText) btnText.textContent = 'Clipboard (Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø)';
            } else if (mode === 'dialog') {
                if (hiddenSelect) hiddenSelect.value = 'Dialog';
                if (btnText) btnText.textContent = 'Dialog (ÊòæÁ§∫ÂØπËØùÊ°Ü)';
            }
        }

        function closeCustomSelect(selectId) {
            const trigger = document.querySelector(`#${selectId} .custom-select-trigger`);
            const options = document.querySelector(`#${selectId} .custom-select-options`);

            if (trigger && options) {
                trigger.classList.remove('active');
                options.classList.remove('show');
            }
        }

        // Ëá™ÂÆö‰πâselectÊéßÂà∂
        function initCustomSelect() {
            const trigger = document.getElementById('customSelectTrigger');
            const options = document.getElementById('customSelectOptions');
            const text = document.getElementById('customSelectText');
            const originalSelect = document.getElementById('model');

            console.log('initCustomSelect called');
            console.log('trigger:', trigger);
            console.log('options:', options);
            console.log('text:', text);
            console.log('originalSelect:', originalSelect);

            if (!trigger || !options || !text || !originalSelect) {
                console.error('Some custom select elements not found');
                return;
            }

            // ÁÇπÂáªËß¶ÂèëÂô®
            trigger.addEventListener('click', (e) => {
                console.log('üîß [DEBUG] Custom select trigger clicked');
                console.log('üîß [DEBUG] Event target:', e.target);
                console.log('üîß [DEBUG] Trigger element:', trigger);
                e.stopPropagation();
                const isActive = trigger.classList.contains('active');
                console.log('üîß [DEBUG] isActive:', isActive);

                if (isActive) {
                    closeCustomSelect();
                } else {
                    openCustomSelect();
                }
            });

            // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠ÔºàÁßªÈô§Ôºå‰ΩøÁî®ÂÖ®Â±ÄÁöÑcloseAllCustomSelectsÔºâ

            function openCustomSelect() {
                console.log('Opening custom select');
                trigger.classList.add('active');
                options.classList.add('show');

                // Âº∫Âà∂ËÆæÁΩÆÊ†∑ÂºèÂ±ûÊÄß
                options.style.opacity = '1';
                options.style.visibility = 'visible';
                options.style.display = 'block';
                options.style.transform = 'translateY(0)';

                console.log('üîß [DEBUG] Model select opened, options count:', options.children.length);
                console.log('üîß [DEBUG] Model options innerHTML:', options.innerHTML);
                console.log('üîß [DEBUG] Model options classList:', options.classList.toString());
                console.log('üîß [DEBUG] Model options style after force:', options.style.cssText);
                console.log('üîß [DEBUG] Model options computed style opacity:', window.getComputedStyle(options).opacity);
                console.log('üîß [DEBUG] Model options computed style visibility:', window.getComputedStyle(options).visibility);
                console.log('üîß [DEBUG] Model options computed style display:', window.getComputedStyle(options).display);
                console.log('üîß [DEBUG] Model options getBoundingClientRect:', options.getBoundingClientRect());
            }

            function closeCustomSelect() {
                console.log('Closing custom select');
                trigger.classList.remove('active');
                options.classList.remove('show');

                // Âº∫Âà∂ÈáçÁΩÆÊ†∑ÂºèÂ±ûÊÄß
                options.style.opacity = '';
                options.style.visibility = '';
                options.style.display = '';
                options.style.transform = '';
            }

            // ÈÄâÊã©ÈÄâÈ°π
            function selectOption(value, displayText) {
                text.textContent = displayText;
                originalSelect.value = value;

                // Êõ¥Êñ∞ÈÄâ‰∏≠Áä∂ÊÄÅ
                document.querySelectorAll('.custom-select-option').forEach(opt => {
                    opt.classList.remove('selected');
                });

                if (value) {
                    const selectedOption = document.querySelector(`[data-value="${value}"]`);
                    if (selectedOption) {
                        selectedOption.classList.add('selected');
                    }
                }

                closeCustomSelect();
                // Settings will be saved manually
            }

            // Êõ¥Êñ∞ÈÄâÈ°π
            window.updateCustomSelectOptions = function() {
                options.innerHTML = '';

                // Ê∑ªÂä†ÈªòËÆ§ÈÄâÈ°π
                const defaultOption = document.createElement('div');
                defaultOption.className = 'custom-select-option';
                defaultOption.textContent = 'Select a model...';
                defaultOption.addEventListener('click', () => selectOption('', 'Select a model...'));
                options.appendChild(defaultOption);

                // Ê∑ªÂä†Ê®°ÂûãÈÄâÈ°π
                Array.from(originalSelect.options).forEach(option => {
                    if (option.value) {
                        const customOption = document.createElement('div');
                        customOption.className = 'custom-select-option';
                        customOption.textContent = option.textContent;
                        customOption.setAttribute('data-value', option.value);
                        customOption.addEventListener('click', () => selectOption(option.value, option.textContent));
                        options.appendChild(customOption);
                    }
                });

                // Êõ¥Êñ∞ÂΩìÂâçÈÄâ‰∏≠Áä∂ÊÄÅ
                const currentValue = originalSelect.value;
                if (currentValue) {
                    const selectedOption = originalSelect.options[originalSelect.selectedIndex];
                    text.textContent = selectedOption.textContent;
                    const customOption = document.querySelector(`[data-value="${currentValue}"]`);
                    if (customOption) {
                        customOption.classList.add('selected');
                    }
                } else {
                    text.textContent = 'Select a model...';
                }
            };
        }

        // Initialize Profile Select
        function initProfileSelect() {
            const trigger = document.getElementById('customProfileTrigger');
            const options = document.getElementById('customProfileOptions');

            if (!trigger || !options) return;

            trigger.addEventListener('click', (e) => {
                console.log('üîß [DEBUG] Profile select trigger clicked!');
                console.log('üîß [DEBUG] Event target:', e.target);
                console.log('üîß [DEBUG] Trigger element:', trigger);
                e.stopPropagation();
                const isActive = trigger.classList.contains('active');
                console.log('üîß [DEBUG] Profile isActive:', isActive);

                // Close all other selects
                closeAllCustomSelects();

                if (!isActive) {
                    trigger.classList.add('active');
                    options.classList.add('show');

                    // Âº∫Âà∂ËÆæÁΩÆÊ†∑ÂºèÂ±ûÊÄß
                    options.style.opacity = '1';
                    options.style.visibility = 'visible';
                    options.style.display = 'block';
                    options.style.transform = 'translateY(0)';

                    console.log('üîß [DEBUG] Profile select opened, options count:', options.children.length);
                    console.log('üîß [DEBUG] Options innerHTML:', options.innerHTML);
                    console.log('üîß [DEBUG] Options classList:', options.classList.toString());
                    console.log('üîß [DEBUG] Options style after force:', options.style.cssText);
                    console.log('üîß [DEBUG] Options computed style opacity:', window.getComputedStyle(options).opacity);
                    console.log('üîß [DEBUG] Options computed style visibility:', window.getComputedStyle(options).visibility);
                    console.log('üîß [DEBUG] Options computed style display:', window.getComputedStyle(options).display);
                    console.log('üîß [DEBUG] Options getBoundingClientRect:', options.getBoundingClientRect());
                }
            });
        }

        // Initialize Tailwind dropdowns
        function initTailwindDropdowns() {
            initProfileDropdown();
            initModelDropdown();
        }

        // Profile dropdown using Tailwind
        function initProfileDropdown() {
            const button = document.getElementById('profileButton');
            const options = document.getElementById('profileOptions');
            const buttonText = document.getElementById('profileButtonText');

            if (!button || !options || !buttonText) return;

            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = !options.classList.contains('hidden');
                
                // Close all dropdowns first
                closeAllTailwindDropdowns();
                
                if (!isOpen) {
                    options.classList.remove('hidden');
                    button.setAttribute('aria-expanded', 'true');
                }
            });

            // Close when clicking outside
            document.addEventListener('click', () => {
                if (!options.classList.contains('hidden')) {
                    options.classList.add('hidden');
                    button.setAttribute('aria-expanded', 'false');
                }
            });
        }

        // Model dropdown using Tailwind  
        function initModelDropdown() {
            const button = document.getElementById('modelButton');
            const options = document.getElementById('modelOptions');
            const buttonText = document.getElementById('modelButtonText');

            if (!button || !options || !buttonText) return;

            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = !options.classList.contains('hidden');
                
                // Close all dropdowns first
                closeAllTailwindDropdowns();
                
                if (!isOpen) {
                    options.classList.remove('hidden');
                    button.setAttribute('aria-expanded', 'true');
                }
            });

            // Close when clicking outside
            document.addEventListener('click', () => {
                if (!options.classList.contains('hidden')) {
                    options.classList.add('hidden');
                    button.setAttribute('aria-expanded', 'false');
                }
            });
        }

        // Close all Tailwind dropdowns
        function closeAllTailwindDropdowns() {
            const allDropdowns = ['profileOptions', 'modelOptions', 'promptModeOptions', 'outputModeOptions'];
            const allButtons = ['profileButton', 'modelButton', 'promptModeButton', 'outputModeButton'];
            
            allDropdowns.forEach(id => {
                const dropdown = document.getElementById(id);
                if (dropdown) dropdown.classList.add('hidden');
            });
            
            allButtons.forEach(id => {
                const button = document.getElementById(id);
                if (button) button.setAttribute('aria-expanded', 'false');
            });
        }

        // Update profile dropdown options
        function updateProfileSelector() {
            const profileOptions = document.getElementById('profileOptions');
            const profileButtonText = document.getElementById('profileButtonText');

            if (!profileOptions || !profileButtonText) return;

            // Clear existing options
            profileOptions.innerHTML = '';

            // Add profile options
            currentProfiles.forEach(profile => {
                const li = document.createElement('li');
                li.className = 'text-gray-900 cursor-default select-none relative py-2 pl-8 pr-4 hover:bg-apple-blue hover:text-white';
                li.setAttribute('role', 'option');
                li.innerHTML = `
                    <span class="font-normal block truncate ${profile.id === currentActiveProfileId ? 'font-semibold' : ''}">${profile.name}</span>
                    ${profile.id === currentActiveProfileId ? '<span class="text-apple-blue absolute inset-y-0 left-0 flex items-center pl-1.5"><svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg></span>' : ''}
                `;
                
                li.addEventListener('click', () => {
                    console.log('üîß [DEBUG] Profile selected from Tailwind dropdown:', profile.id);
                    const hiddenSelect = document.getElementById('profileSelect');
                    hiddenSelect.value = profile.id;
                    switchToProfile(profile.id);
                    profileButtonText.textContent = profile.name;
                    closeAllTailwindDropdowns();
                });

                profileOptions.appendChild(li);
            });

            // Update button text with current profile
            if (currentActiveProfileId) {
                const activeProfile = currentProfiles.find(p => p.id === currentActiveProfileId);
                if (activeProfile) {
                    profileButtonText.textContent = activeProfile.name;
                }
            }
        }

        // Update model dropdown options (supports custom input)
        function updateModelDropdown(models) {
            const modelOptions = document.getElementById('modelOptions');
            const modelButtonText = document.getElementById('modelButtonText');

            if (!modelOptions || !modelButtonText) return;

            // Normalize models list
            const list = Array.isArray(models) ? models : [];

            // Clear existing options
            modelOptions.innerHTML = '';

            // Add default option
            const defaultLi = document.createElement('li');
            defaultLi.className = 'text-gray-900 cursor-default select-none relative py-2 pl-8 pr-4 hover:bg-apple-blue hover:text-white';
            defaultLi.setAttribute('role', 'option');
            defaultLi.innerHTML = '<span class="font-normal block truncate">Select a model...</span>';
            defaultLi.addEventListener('click', () => {
                const hiddenSelect = document.getElementById('model');
                hiddenSelect.value = '';
                modelButtonText.textContent = 'Select a model...';
                closeAllTailwindDropdowns();
            });
            modelOptions.appendChild(defaultLi);

            // Add a custom model option
            const customLi = document.createElement('li');
            customLi.className = 'text-gray-900 cursor-default select-none relative py-2 pl-8 pr-4 hover:bg-apple-blue hover:text-white';
            customLi.setAttribute('role', 'option');
            customLi.innerHTML = '<span class="font-normal block truncate">Custom model‚Ä¶</span>';
            customLi.addEventListener('click', async () => {
                const hiddenSelect = document.getElementById('model');
                const current = hiddenSelect.value || '';
                const value = await showInputDialog('Custom Model', 'Enter model name or ID:', current);
                if (value) {
                    const exists = Array.from(hiddenSelect.options).some(o => o.value === value);
                    if (!exists) {
                        const opt = document.createElement('option');
                        opt.value = value;
                        opt.textContent = value;
                        hiddenSelect.appendChild(opt);
                    }
                    hiddenSelect.value = value;
                    modelButtonText.textContent = value;
                }
                closeAllTailwindDropdowns();
            });
            modelOptions.appendChild(customLi);

            // Add model options
            list.forEach(modelId => {
                const li = document.createElement('li');
                li.className = 'text-gray-900 cursor-default select-none relative py-2 pl-8 pr-4 hover:bg-apple-blue hover:text-white';
                li.setAttribute('role', 'option');
                li.innerHTML = `<span class="font-normal block truncate">${modelId}</span>`;
                
                li.addEventListener('click', () => {
                    console.log('üîß [DEBUG] Model selected from Tailwind dropdown:', modelId);
                    const hiddenSelect = document.getElementById('model');
                    hiddenSelect.value = modelId;
                    modelButtonText.textContent = modelId;
                    closeAllTailwindDropdowns();
                });

                modelOptions.appendChild(li);
            });

            // Reflect current selection in button text
            const hiddenSelect = document.getElementById('model');
            if (hiddenSelect && hiddenSelect.value) {
                modelButtonText.textContent = hiddenSelect.value;
            }
        }

        // Initialize Prompt Mode dropdown
        function initPromptModeDropdown() {
            const button = document.getElementById('promptModeButton');
            const options = document.getElementById('promptModeOptions');
            const buttonText = document.getElementById('promptModeButtonText');
            const hiddenSelect = document.getElementById('promptMode');

            if (!button || !options || !buttonText || !hiddenSelect) return;

            // Setup click handler for button
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = !options.classList.contains('hidden');
                
                // Close all dropdowns first
                closeAllTailwindDropdowns();
                
                if (!isOpen) {
                    options.classList.remove('hidden');
                    button.setAttribute('aria-expanded', 'true');
                }
            });

            // Close when clicking outside
            document.addEventListener('click', () => {
                if (!options.classList.contains('hidden')) {
                    options.classList.add('hidden');
                    button.setAttribute('aria-expanded', 'false');
                }
            });

            // Populate options
            updatePromptModeDropdown();
        }

        // Initialize Output Mode dropdown
        function initOutputModeDropdown() {
            const button = document.getElementById('outputModeButton');
            const options = document.getElementById('outputModeOptions');
            const buttonText = document.getElementById('outputModeButtonText');
            const hiddenSelect = document.getElementById('outputMode');

            if (!button || !options || !buttonText || !hiddenSelect) return;

            // Setup click handler for button
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = !options.classList.contains('hidden');
                
                // Close all dropdowns first
                closeAllTailwindDropdowns();
                
                if (!isOpen) {
                    options.classList.remove('hidden');
                    button.setAttribute('aria-expanded', 'true');
                }
            });

            // Close when clicking outside
            document.addEventListener('click', () => {
                if (!options.classList.contains('hidden')) {
                    options.classList.add('hidden');
                    button.setAttribute('aria-expanded', 'false');
                }
            });

            // Populate options
            updateOutputModeDropdown();
        }

        // Update Prompt Mode dropdown options
        function updatePromptModeDropdown() {
            const promptModeOptions = document.getElementById('promptModeOptions');
            const promptModeButtonText = document.getElementById('promptModeButtonText');

            if (!promptModeOptions || !promptModeButtonText) return;

            // Clear existing options
            promptModeOptions.innerHTML = '';

            const modes = [
                { value: 'Predefined', text: 'Predefined Prompt' },
                { value: 'UserInput', text: 'User Input (ÊØèÊ¨°ËØ¢ÈóÆ)' }
            ];

            modes.forEach(mode => {
                const li = document.createElement('li');
                li.className = 'text-gray-900 cursor-default select-none relative py-2 pl-8 pr-4 hover:bg-apple-blue hover:text-white';
                li.setAttribute('role', 'option');
                li.innerHTML = `<span class="font-normal block truncate">${mode.text}</span>`;
                
                li.addEventListener('click', () => {
                    console.log('üîß [DEBUG] Prompt mode selected:', mode.value);
                    const hiddenSelect = document.getElementById('promptMode');
                    hiddenSelect.value = mode.value;
                    promptModeButtonText.textContent = mode.text;
                    closeAllTailwindDropdowns();
                    
                    // Show/hide prompt text group based on selection
                    const promptTextGroup = document.getElementById('promptTextGroup');
                    if (promptTextGroup) {
                        if (mode.value === 'Predefined') {
                            promptTextGroup.style.display = 'block';
                        } else {
                            promptTextGroup.style.display = 'none';
                        }
                    }
                });

                promptModeOptions.appendChild(li);
            });
        }

        // Update Output Mode dropdown options
        function updateOutputModeDropdown() {
            const outputModeOptions = document.getElementById('outputModeOptions');
            const outputModeButtonText = document.getElementById('outputModeButtonText');

            if (!outputModeOptions || !outputModeButtonText) return;

            // Clear existing options
            outputModeOptions.innerHTML = '';

            const modes = [
                { value: 'Clipboard', text: 'Clipboard (Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø)' },
                { value: 'Dialog', text: 'Dialog (ÊòæÁ§∫ÂØπËØùÊ°Ü)' }
            ];

            modes.forEach(mode => {
                const li = document.createElement('li');
                li.className = 'text-gray-900 cursor-default select-none relative py-2 pl-8 pr-4 hover:bg-apple-blue hover:text-white';
                li.setAttribute('role', 'option');
                li.innerHTML = `<span class="font-normal block truncate">${mode.text}</span>`;
                
                li.addEventListener('click', () => {
                    console.log('üîß [DEBUG] Output mode selected:', mode.value);
                    const hiddenSelect = document.getElementById('outputMode');
                    hiddenSelect.value = mode.value;
                    outputModeButtonText.textContent = mode.text;
                    closeAllTailwindDropdowns();
                });

                outputModeOptions.appendChild(li);
            });
        }

        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ [DEBUG] DOMContentLoaded event fired');
            console.log('üöÄ [DEBUG] Page loaded, initializing...');

            // È™åËØÅÈáçË¶ÅÂáΩÊï∞ÊòØÂê¶Â∑≤Êö¥Èú≤
            console.log('üîß [DEBUG] createNewProfile in window:', typeof window.createNewProfile);
            console.log('üîß [DEBUG] deleteCurrentProfile in window:', typeof window.deleteCurrentProfile);
            console.log('üîß [DEBUG] captureGlobalHotkey in window:', typeof window.captureGlobalHotkey);
            console.log('üîß [DEBUG] captureSwitchHotkey in window:', typeof window.captureSwitchHotkey);
            console.log('üîß [DEBUG] loadSettings in window:', typeof window.loadSettings);
            console.log('üîß [DEBUG] saveSettings in window:', typeof window.saveSettings);
            console.log('üîß [DEBUG] tauriInvoke in window:', typeof window.tauriInvoke);
            
            // ÂÖ∂‰ªñÂáΩÊï∞Â¶ÇÊûúÈúÄË¶Å‰πüÂèØ‰ª•Âú®ËøôÈáåÊö¥Èú≤
            // ‰∏ªË¶ÅÁöÑonclickÂáΩÊï∞Â∑≤ÁªèÂú®ÂÆö‰πâÂêéÁ´ãÂç≥Êö¥Èú≤‰∫Ü
            
            // ÂàùÂßãÂåñTailwind‰∏ãÊãâËèúÂçï
            console.log('üîß [DEBUG] Initializing Tailwind dropdowns...');
            initTailwindDropdowns();
            initPromptModeDropdown();
            initOutputModeDropdown();
            
            // Âä†ËΩΩËÆæÁΩÆ
            console.log('üîß [DEBUG] Loading settings...');
            try {
                await loadSettings();
                console.log('‚úÖ [DEBUG] Settings loaded successfully');
            } catch (error) {
                console.error('‚ùå [DEBUG] Error loading settings:', error);
            }
            
            console.log('‚úÖ [DEBUG] Initialization complete');

            // ÊµãËØïÂáΩÊï∞ÊòØÂê¶ÂèØ‰ª•Ë∞ÉÁî®
            console.log('üß™ [DEBUG] Testing function accessibility...');
            try {
                if (typeof window.createNewProfile === 'function') {
                    console.log('‚úÖ [DEBUG] createNewProfile is accessible');
                } else {
                    console.error('‚ùå [DEBUG] createNewProfile is not accessible');
                }

                if (typeof window.captureGlobalHotkey === 'function') {
                    console.log('‚úÖ [DEBUG] captureGlobalHotkey is accessible');
                } else {
                    console.error('‚ùå [DEBUG] captureGlobalHotkey is not accessible');
                }

                if (typeof window.loadSettings === 'function') {
                    console.log('‚úÖ [DEBUG] loadSettings is accessible');
                } else {
                    console.error('‚ùå [DEBUG] loadSettings is not accessible');
                }
            } catch (error) {
                console.error('‚ùå [DEBUG] Error testing functions:', error);
            }
        });
    </script>
</body>
</html>
